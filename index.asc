:source-highlighter: pygments
:toc: left
:stem:

= Processamento Digital de Imagens

Bruno Silva

Link para as atividades: link:https://agostinhobritojr.github.io/tutorial/pdi/[atividades]

== 7. Filtragem no domínio da frequência

Programa de link:https://agostinhobritojr.github.io/tutorial/pdi/#_filtragem_no_dom%C3%ADnio_da_frequ%C3%AAncia[exemplo]

=== 7.1 Exercícios

O exercíco propõe a criação de um programa que auxilie no melhoramento de imagens com iluminação irregular utilizando o 
filtro homomórfico, para tal foi criada uma interface com _sliders_ para ajustar os paramentros do filtro e são mostradas 
em janelas diferentes a imagem com a aplicação do filtro, a imagem original e o filtro que está sendo aplicado.

Para compilar e executar o programa link:../filtragem_frequencia/homomorfico.cpp[homomorfico.cpp], salve-o juntamente com o arquivo 
link:../Makefile[Makefile] em um diretório e execute a seguinte sequência de comandos:

Arquivo: homomorfico.cpp[homomorfico.cpp]

[source, shell]
----
#include <iostream>
#include <opencv2/opencv.hpp>
#include <cmath>

using namespace cv;
using namespace std;

int c_slider = 0;
int c_slider_max = 100;

int gamaL_slider = 0;
int gamaL_slider_max = 100;

int gamaH_slider = 0;
int gamaH_slider_max = 100;

int d0_slider = 0;
int d0_slider_max = 100;

Mat image1, image2, blended;
Mat imageTop;

char TrackbarName[50];

Mat padded, filter, mag, complexImage;
Mat image, imagegray, tmp, imageO, imagegrayO;
Mat_<float> realInput, zeros;
vector<Mat> planos;
int dft_M, dft_N;

void deslocaDFT(Mat& image ){
    Mat tmp, A, B, C, D;

    // se a imagem tiver tamanho impar, recorta a regiao para
    // evitar cópias de tamanho desigual
    image = image(Rect(0, 0, image.cols & -2, image.rows & -2));
    int cx = image.cols/2;
    int cy = image.rows/2;

    // reorganiza os quadrantes da transformada
    // A B   ->  D C
    // C D       B A
    A = image(Rect(0, 0, cx, cy));
    B = image(Rect(cx, 0, cx, cy));
    C = image(Rect(0, cy, cx, cy));
    D = image(Rect(cx, cy, cx, cy));

    // A <-> D
    A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

    // C <-> B
    C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}

void on_trackbar(int, void*){

    imageO.copyTo(image);
    image.convertTo(image, CV_32F);
    log(image, image);

    dft_M = getOptimalDFTSize(image.rows);
    dft_N = getOptimalDFTSize(image.cols);

    // realiza o padding da imagem
    copyMakeBorder(image, padded, 0,
                   dft_M - image.rows, 0,
                   dft_N - image.cols,
                   BORDER_CONSTANT, Scalar::all(0));

    // parte imaginaria da matriz complexa (preenchida com zeros)
    zeros = Mat_<float>::zeros(padded.size());

    // prepara a matriz complexa para ser preenchida
    complexImage = Mat(padded.size(), CV_32FC2, Scalar(0));

    // a função de transferência (filtro frequencial) deve ter o
    // mesmo tamanho e tipo da matriz complexa
    filter = complexImage.clone();

    // cria uma matriz temporária para criar as componentes real
    // e imaginaria do filtro ideal
    tmp = Mat(dft_M, dft_N, CV_32F);

    cvtColor(imageO, imagegrayO, CV_BGR2GRAY);
    imshow("original", imagegrayO);
    cvtColor(image, imagegray, CV_BGR2GRAY);

    // realiza o padding da imagem
    copyMakeBorder(imagegray, padded, 0,
                   dft_M - image.rows, 0,
                   dft_N - image.cols,
                   BORDER_CONSTANT, Scalar::all(0));
    // limpa o array de matrizes que vao compor a
    // imagem complexa
    planos.clear();
    // cria a compoente real
    realInput = Mat_<float>(padded);
    // insere as duas componentes no array de matrizes
    planos.push_back(realInput);
    planos.push_back(zeros);

    // combina o array de matrizes em uma unica
    // componente complexa
    merge(planos, complexImage);

    // calcula o dft
    dft(complexImage, complexImage);

    // realiza a troca de quadrantes
    deslocaDFT(complexImage);

    float d0, gamaH, gamaL;
    gamaL = gamaL_slider/10.0;
    gamaH = gamaH_slider/10.0;
    d0 = d0_slider/10.0;

    // prepara o filtro passa-baixas ideal
    for(int i=0; i<dft_M; i++){

        for(int j=0; j<dft_N; j++){
            tmp.at<float> (i,j) = (gamaH - gamaL) *
                    (1.0 - exp(-1.0 * (float)c_slider * ((pow(((float) i - dft_M/2.0),2)+pow(((float) j - dft_N/2.0),2))/(d0*d0)) ))
                    + gamaL;
        }
    }

    // cria a matriz com as componentes do filtro e junta
    // ambas em uma matriz multicanal complexa
    Mat comps[]= {tmp, tmp};
    merge(comps, 2, filter);

    // aplica o filtro frequencial
    mulSpectrums(complexImage,filter,complexImage,0);

    // troca novamente os quadrantes
    deslocaDFT(complexImage);

    // calcula a DFT inversa
    idft(complexImage, complexImage);

    // limpa o array de planos
    planos.clear();

    // separa as partes real e imaginaria da
    // imagem filtrada
    split(complexImage, planos);

    // normaliza a parte real para exibicao
    normalize(planos[0], planos[0], 0, 1, CV_MINMAX);
    planos[0].convertTo(planos[0], CV_32F);
    imshow("addweighted", planos[0]);
}

int main(int argvc, char** argv){

    imageO = imread("biel.png");

    namedWindow("addweighted", 1);
    sprintf( TrackbarName, "C x %d", c_slider_max );
    createTrackbar( TrackbarName, "addweighted",
                    &c_slider,
                    c_slider_max,
                    on_trackbar);
    on_trackbar(c_slider, 0 );

    sprintf( TrackbarName, "GAMA L x %d", gamaL_slider_max );
    createTrackbar( TrackbarName, "addweighted",
                    &gamaL_slider,
                    gamaL_slider_max,
                    on_trackbar);
    on_trackbar(gamaL_slider, 0 );

    sprintf( TrackbarName, "GAMA H x %d", gamaH_slider_max );
    createTrackbar( TrackbarName, "addweighted",
                    &gamaH_slider,
                    gamaH_slider_max,
                    on_trackbar);
    on_trackbar(gamaH_slider, 0 );

    sprintf( TrackbarName, "D0 x %d", d0_slider_max );
    createTrackbar( TrackbarName, "addweighted",
                    &d0_slider,
                    d0_slider_max,
                    on_trackbar);
    on_trackbar(d0_slider, 0 );


    waitKey(0);
    return 0;
}
----

O código acima consiste em realizar o processo de filtragem. Na primeira parte, tratamos a imagem, onde se é aplicada um logaritmo natural antes de levar para o domínio da frequência.

---
    ​image.convertTo(image, CV_32F);
    log(image, image);
---

Então se realiza a transformada de Fourier:

---
    ​dft(complexImage, complexImage);
    deslocaDFT(complexImage);
---

Então é aplicado o filtro na imagem:

---
    float d0, gamaH, gamaL;
   ​gamaL = gamaL_slider/10.0;
   ​gamaH = gamaH_slider/10.0;
   ​d0 = d0_slider/10.0;

   ​// prepara o filtro passa-baixas ideal
   ​for(int i=0; i<dft_M; i++){

       ​for(int j=0; j<dft_N; j++){
           ​tmp.at<float> (i,j) = (gamaH - gamaL) *
                   ​(1.0 - exp(-1.0 * (float)c_slider * ((pow(((float) i - dft_M/2.0),2)+pow(((float) j - dft_N/2.0),2))/(d0*d0)) ))
                   ​+ gamaL;
       ​}
   ​}

   ​// cria a matriz com as componentes do filtro e junta
   ​// ambas em uma matriz multicanal complexa
   ​Mat comps[]= {tmp, tmp};
   ​merge(comps, 2, filter);

   ​// aplica o filtro frequencial
   ​mulSpectrums(complexImage,filter,complexImage,0);

---

Então é aplicada a inversa de Fourier e a exponencial na imagem no domínio do espaço:

---
   deslocaDFT(complexImage);
   ​idft(complexImage, complexImage);

   ​planos.clear();

   ​// separa as partes real e imaginaria da imagem filtrada
   ​split(complexImage, planos);

   ​// normaliza a parte real para exibicao
   ​normalize(planos[0], planos[0], 0, 1, CV_MINMAX);
   ​planos[0].convertTo(planos[0], CV_32F);


image::../imgs/homomorfico_original.png[Original, title="Original", width=1200, height=330]
image::../imgs/homomorfico1.png[Imagem filtrada 1, title="Imagem filtrada 1", role="left", width=256, height=256]
image::../imgs/homomorfico2.png[Imagem filtrada 2, title="Imagem filtrada 2", role="center", width=256, height=256]
image::../imgs/homomorfico3.png[Imagem filtrada 3, title="Imagem filtrada 3", role="right", width=256, height=256]

== 8 Detecção de bordas com o algoritmo de Canny

Programa de link:https://agostinhobritojr.github.io/tutorial/pdi/#_canny_e_a_arte_com_pontilhismo[exemplo]

=== 8.1 Canny e a arte com pontilhismo

Programa de link:https://agostinhobritojr.github.io/tutorial/pdi/#_canny_e_a_arte_com_pontilhismo[exemplo]

=== 8.2 Exercícios

O exercício solicita a implementação de um programa para usar as bordas produzidas pelo algoritmo de Canny para 
melhorar a qualidade da imagem pontilhista gerada, para tal utiliza-se a posição dos pixels de borda encontrados pelo 
algoritmo de Canny para desenhar pontos nos respectivos locais na imagem gerada através da seguinte função:

[source, cpp]
----
void getPointillisticImage() {
    // Cria variaveis para as dimensoes da imagem
    int height = image.size().height, width = image.size().width;

    // Cria as matrizes para as bordas da imagem e para a imagem de pontos 
    points = Mat(height, width, CV_8UC3, Scalar(255, 255, 255));

    Canny(image, edges, canny_slider, 3 * canny_slider);

    // Percorre a matriz com as bordas e preenche um vetor com as coordenadas
    // dos pixels de valor 255
    vector<vector<int>> edgesCoordinates;

    for(int i = 0; i < height; i++) {
        for(int j = 0; j < width; j++) {
            if(edges.at<uchar>(i, j) == 255) {
                edgesCoordinates.push_back({i, j});
            }
        }
    }

    // Embaralha as coordenas onde os circulos serão desenhados 
    // para aumentar a autenticidade do resultado 
    random_shuffle(edgesCoordinates.begin(), edgesCoordinates.end());

    // Percorre as coordenadas e desenha em uma nova matrix os pontos 
    // com cor igual a cor da imagem na posição correspodente
    for(auto coordinate : edgesCoordinates) {
        Vec3b color = image.at<Vec3b>(coordinate[0], coordinate[1]);
        
        circle(points, Point(coordinate[1], coordinate[0]), RAIO, color, -1, CV_AA);
    }
    
}
----

A função mostrada acima tem o objetivo de sempre que o treshold do Canny for alterado na interface 
uma nova imagem pontilhista seja gerada, calculando as bordas com o algoritmo Canny em seguida 
procurando os pixels de borda e salvando suas posições em um vetor então emlhara-se esse vetor 
para melhorar a autenticidade do efeito, por fim o vetor de coordenadas é percorrido e são desenhados 
circulos em cada uma das posições preenchidos com as cores do pixel correspondente na imagem original.

Para compilar e executar o programa link:../bordas/cannyPoints.cpp[cannyPoints.cpp], salve-o juntamente com o arquivo 
link:../Makefile[Makefile] em um diretório e execute a seguinte sequência de comandos:

[source, shell]
----
$ make cannyPoints
$ ./cannyPoints <caminho_para_imagem>
----

image::../imgs/interface_canny.png[Interface, title="Interface", width=256, height=256]
image::../imgs/sunflowers.jpg[Entrada do programa, title="Entrada do programa", role="left", width=256, height=256]
image::../imgs/sunflowers_points.jpg[Saída do programa, title="Saída do programa", role="center", width=256, height=256]

== 9 Quantização vetorial com k-means

Programa de link:https://agostinhobritojr.github.io/tutorial/pdi/#_quantiza%C3%A7%C3%A3o_vetorial_com_k_means[exemplo]

=== 9.1 Exercícios 

A atividade solicita a modificação do exemplo fornecido para que a inicialização dos centróides seja feita 
utilizando o parâmetro KMEANS_RANDOM_CENTERS. Para tal a função kmeans utilizada está descrita na listagem 
a seguir.

[source, cpp]
----
kmeans(
    samples,
    nClusters,
    rotulos,
    TermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 100, 0.01),
    nRodadas,
    KMEANS_RANDOM_CENTERS,
    centros
);
----

Para compilar e executar o programa link:../segmentacao/kmeans_random_centers.cpp[kmeans_random_centers.cpp] 10 vezes, salve-o 
juntamente com o arquivo link:../Makefile[Makefile] em um diretório e execute a seguinte sequência de comandos:

[source, shell]
----
$ make kmeans_random_centers
$ for i in `seq 1 10`;do ./kmeans_random_centers.out <caminho_para_imagem> <numero_de_clusters>; done
----

As imagens podem diferir devido ao ponto inicial que cada centróide pode assumir e a não existência de mais rodadas 
para definir a melhor iteração da aplicação do algoritmo.

== Trabalho Final

O trabalho final da disciplina intitulado "Classificação da orientação da cabeça de camundongos" teve como 
objetivo criar uma ferramenta para auxilio na execução de experimentos de neurociência comportamental 
que requerem a localização precisa de um animal em um dado ambiente e a direção de seu olhar.

Para o desenvolvimento do algoritmo a seguinte configuração experimental foi utilizada:

image::../imgs/tf_confExp.png[Configuração Experimental, title="Configuração Experimental"]

Para realizar a segmentação do animal foi subtraido do frame atual o primeiro frame com apenas o 
fundo da cena em seguida um treshold para a faixa de cor do animal após a subtração é aplicado como 
ilustrado na figura a seguir.

image::../imgs/tf_segmentation.png[Segementação, title="Estratégia de Segmentação"]

Após realizar a segmentação a imagem obtida por vezes ficava descontinua em certos pontos, portanto
para suavizar tal imagem foi aplicada uma abertura morfológica como ilustrado a seguir.

image::../imgs/tf_morph.png[Morph, title="Abertura Morfológica"]

Por fim para obter a orientação da cabeça foi utilizado a Análise de Componentes Principais 
(PCA, da sigla em inglês), o resultado do processamento pode ser visto na imagem a seguir.

image::../imgs/tf_pca.png[PCA, title="Análise de Componentes Principais"]

O código utilizado está disponivel em link:../trabalho_final/headOrientation.py[headOrientation.py]
para executa-lo execute a seguinte sequência de comandos:

[source, shell]
----
$ python headOrientation.py <Video> <Imagem_de_fundo>
----